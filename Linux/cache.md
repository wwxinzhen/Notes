##### 1、CAP理论

​	C（一致性）：所有的节点上的数据时刻保持同步

​	A（可用性）：每个请求都能接收到一个响应，无论响应成功或失败

​	P（分区容错）：系统应该能持续提供服务，即使系统内部有消息丢失

​	一致性、可用性和分区容错性三者无法在分布式系统中被同步满足，并且最多只能满足其中两个

##### 2、Bit-map

​	用一个bit位来标记某个元素对应的Value，而Key即是该元素经过转换（比如hash）得到的值。由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。

##### 3、布隆过滤器

​	是一个**很长的二进制向量**和**一系列随机映射函数**。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

​	原理：

​		当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位数组中的K个点，把他们置为1。检索时，只要看这些点是不是为1就知道集合中有没有它了。如果这些点有1个0，则肯定不存在；如果都为1，则大概率存在。当元素a、b的hash出来的index是一样的时候就无法判断bit-map里面存的是a还是b，所以一般布隆过滤器不允许删除元素。

​	布隆过滤器hash冲突性与散列函数的设计和Bit-map的大小有关，如果Bit-map太小那必然很多元素都会落到同一个下标，并且后面数量越大冲突也就越大。

​	当存储元素量不是很大的话，可以优先考虑散列表(map)，数量大时选择布隆过滤器。

##### 4、数据一致性

​	缓存和DB的一致性，我们指的更多的是最终一致性。我们使用缓存主要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。

##### 5、更新缓存的设计模式

```
Cache Aside Pattern（旁路缓存）
	这里是最常用的pattern，具体逻辑如下：
		失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
		命中：应用程序从cache中取数据，取到后返回。
	更新：先把数据存到数据库中，成功后，再让缓存失效。
	要么通过2PC或Paxos协议保证一致性，还么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是要为缓存设置上过期时间。
Read/Write Through Pattern
	上面的方式，应用代码需要维护两个数据存储，一个是cache，一个是db，而这个策略是把更新db的操作由cache自己处理。
	Read Through
		Read Through是在查询操作中更新cache，也就是说，当cache失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载如cache，而Read Through则用cache服务自己来加载。
	Write Through
		Write Through是在更新数据时发生。当有数据更新的时候，如果没有命中cache，直接更新db，然后返回。如果命中了cache，则更新cache，然后由cache更新db。
Write Behind Caching Pattern
	Write Behind又叫Write Back，write back就是Linux文件系统的Page Cache的算法。
	在更新数据的时候，只更新cache，cache会异步的批量更新db。
	这个设计的好处是数据I/O速度快，因为异步，wirte back还可以合并对同一个数据的多次操作。
	但是带来的问题是，数据不是强一致性的，而且可能会丢失（linux非正常关机会导致数据丢失）
```

##### 6、缓存架构设计

```
更新缓存 VS 淘汰缓存
	更新缓存：数据不但写入数据库，还会写入缓存；优点：缓存不会增加一次miss，命中率高
	淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉；优点：简单
	两者的选择主要取决于更新缓存的复杂度
	淘汰缓存操作简单，并且带来的副作用只是增加一次cache miss，建议作为通用的处理方式。
先操作数据库 VS 先操作缓存
	先操作数据库：第一步写数据库操作成功，第二部淘汰缓存失败，则会出现DB是新数据，Cache是旧数据，数据不一致。
	先淘汰缓存：第一步淘汰缓存成功，第二部写数据库失败，则只会引发一次Cache miss
	结论：先淘汰缓存，再写数据库
```

##### 7、缓存穿透 & 缓存雪崩 & 缓存击穿

缓存穿透

​	查询一个一定不存在的数据，因为缓存中没有改数据的信息，则会直接去数据库进行查询

​	解决办法：

​		布隆过滤器

​		空值缓存：在第一次查询完不存在的数据后，将该key与对应空值也放入缓存，只不过设定为较短的失效时间。

缓存雪崩

​	缓存在同一时间失效，素有系统的请求都发送到数据库

​	解决办法：

​		线程互斥

​		交错失效时间

缓存击穿

​	缓存击穿实际上是缓存雪崩的一个特例。与雪崩的区别在于击穿是对于特定的热点数据来说，而雪崩是全部数据，

​	解决方法：

​		二级缓存：对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间，则请求不会直接击穿缓存到达数据库。